{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TemplateHaskell   #-}
{-# LANGUAGE MultiParamTypeClasses #-}
module Kiosk.Backend.Data.Migrations.StandardizationSpec (spec,main) where


import           Language.Haskell.TH
import           Test.Hspec
-- import           Test.HUnit


import Data.Text (Text,pack,unpack)                                               

import Kiosk.Backend.Data.Migrations.Standardization









import Regex.Genex
import Test.QuickCheck
import Control.Arrow ((***))


main :: IO ()
main = hspec spec

-- * Code 
spec :: Spec
spec = describe (nameBase 'standardize) $ do
         it "should return the Standard form for any of the strings generated by the target" $ 
          checkStandardizer


regexStringGenerator :: String -> Gen String
regexStringGenerator regexString = elements . genexPure $ [regexString]


regexTextGenerator :: Text -> Gen Text
regexTextGenerator regexText = fmap pack . elements . genexPure $ [unpack regexText]


-- | Big Star Standardizer
bigStarText :: Text
bigStarText = "Big Star Company"


bigStarTextUnstandard :: Text 
bigStarTextUnstandard = "[Bb][iI][gG] [Ss][tT][aA][rR] Company"                      



bigStarStandardizer :: Standardizer                      
bigStarStandardizer = createStandardizer bigStarRegexForm bigStarStandardForm
   where bigStarRegexForm = makeRegexForm bigStarTextUnstandard                      
         bigStarStandardForm = makeStandardForm bigStarText

-- | Another Standardizer   
checkStandardizer :: Property
checkStandardizer = forAll (regexTextGenerator bigStarTextUnstandard) (\t -> standardize testStandardizer t == bigStarText)
  where
    testStandardizer = bigStarStandardizer
