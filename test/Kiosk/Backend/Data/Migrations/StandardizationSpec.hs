{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TemplateHaskell   #-}
{-# LANGUAGE MultiParamTypeClasses #-}
module Kiosk.Backend.Data.Migrations.StandardizationSpec (spec,main) where

import Kiosk.Backend.Data.Migrations.Standardization

import Data.Text (Text,pack,unpack)
import Language.Haskell.TH
import Regex.Genex
import Test.Hspec
import Test.QuickCheck
import Text.Regex.TDFA.Text ()

main :: IO ()
main = hspec spec

-- * Code 
spec :: Spec
spec = describe (nameBase 'standardize) $ do
         it "should return the Standard form for any of the strings generated by the target" $ 
          checkStandardizer


regexStringGenerator :: String -> Gen String
regexStringGenerator regexString = elements . genexPure $ [regexString]


regexTextGenerator :: Text -> Gen Text
regexTextGenerator regexText = fmap pack . elements . genexPure $ [unpack regexText]


-- | Big Star Standardizer
bigStarText :: Text
bigStarText = "Big Star Company"


bigStarTextUnstandard :: Text 
bigStarTextUnstandard = "[Bb][iI][gG] [Ss][tT][aA][rR] Company"                      



bigStarStandardizer :: Standardizer                      
bigStarStandardizer = createStandardizer bigStarRegexForm bigStarStandardForm
   where bigStarRegexForm = makeRegexForm bigStarTextUnstandard                      
         bigStarStandardForm = makeStandardForm bigStarText

-- | Another Standardizer   
checkStandardizer :: Property
checkStandardizer = forAll (regexTextGenerator bigStarTextUnstandard) (\t -> standardize testStandardizer t == bigStarText)
  where
    testStandardizer = bigStarStandardizer
